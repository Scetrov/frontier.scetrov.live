# Sui CLI instructions for contributors

This file documents the `sui` command-line tool as used by this repository's contributors. It was autogenerated by inspecting `sui --help` and subcommands. Focus is on the commands you will most often use: starting a local network, generating genesis, managing keys, publishing Move packages, and common client actions.

Shortcuts:

- `sui --help` — top-level help

- `sui <COMMAND> --help` — help for any subcommand

## Complete Command Tree

The `sui` CLI is organized into the following top-level commands:

```text
sui
├── start                  # Start local network
├── network                # Network configuration utilities
├── genesis                # Bootstrap new network
├── genesis-ceremony       # Multi-party genesis ceremony
├── keytool                # Key management and signing
├── client                 # Network interaction (primary developer tool)
│   ├── active-address
│   ├── active-env
│   ├── addresses
│   ├── balance
│   ├── call
│   ├── chain-identifier
│   ├── dynamic-field
│   ├── envs
│   ├── execute-signed-tx
│   ├── execute-combined-signed-tx
│   ├── faucet
│   ├── gas
│   ├── merge-coin
│   ├── new-address
│   ├── new-env
│   ├── object
│   ├── objects
│   ├── pay
│   ├── pay-all-sui
│   ├── pay-sui
│   ├── ptb               # Programmable Transaction Blocks
│   ├── publish
│   ├── serialized-tx
│   ├── split-coin
│   ├── transfer
│   ├── transfer-sui
│   ├── upgrade
│   └── verify-source
├── validator              # Validator operations
├── move                   # Move package development
│   ├── build
│   ├── test
│   ├── coverage
│   │   ├── summary
│   │   ├── source
│   │   ├── bytecode
│   │   └── lcov
│   ├── new
│   ├── migrate
│   ├── manage-package
│   └── summary
├── bridge-committee-init  # Bridge committee setup
├── fire-drill             # Operational drills
├── analyze-trace          # Trace analysis
│   └── gas-profile
└── replay                 # Transaction replay
```

## Start a local development network

Typical flow to run a local network for development and testing:

- Generate genesis (one-time or when you want a fresh network):
  `sui genesis --write-config ./sui-config --with-faucet --committee-size 4`

- Start the network (persisted state dir):
  `sui start --network.config ./sui-config`

- Start from scratch (force regenesis) every run:
  `sui start --force-regenesis --with-faucet --with-indexer --with-graphql`

Important flags for `sui start`:

- `--with-faucet[=HOST:PORT]` — run a local faucet (default 0.0.0.0:9123)

- `--with-indexer[=HOST:PORT]` — run indexer (default 0.0.0.0:9124)

- `--with-graphql[=HOST:PORT]` — run graphql (default 0.0.0.0:9125)

- `--pg-*` flags — configure Postgres used by the indexer

- `--no-full-node` — run network without a fullnode

Notes:

- Indexer/GraphQL require Postgres; the `--pg-*` flags let you set connection details.

- ProtocolConfig overrides are possible via environment variables prefixed with
  `SUI_PROTOCOL_CONFIG_OVERRIDE_`. Use with care — mismatched protocol configs across
  validators will break non-local networks.

## Genesis and genesis-ceremony

- `sui genesis --write-config <PATH>` — build a genesis config and write it to <PATH>
- `sui genesis --with-faucet` — include faucet configuration in generated genesis
- `sui genesis-ceremony <subcommand>` — helper commands to manage ceremony steps

Common `genesis-ceremony` subcommands:

- `init`, `validate-state`, `add-validator`, `list-validators`, `build-unsigned-checkpoint`,
  `examine-genesis-checkpoint`, `verify-and-sign`, `finalize`.

Example: add a validator during genesis ceremony:

```bash
sui genesis-ceremony add-validator --name "my-val" --validator-key-file validator.pem \
  --worker-key-file worker.pem --account-key-file account.pem --network-key-file network.pem \
  --network-address 127.0.0.1:12345 --p2p-address 127.0.0.1:45678 \
  --narwhal-primary-address 127.0.0.1:6789 --narwhal-worker-address 127.0.0.1:6790 \
  --description "Local validator"
```

## Key management (`sui keytool`)

Typical operations:

- `sui keytool generate` — create mnemonic/keypair (supports ed25519, secp256k1, secp256r1)

- `sui keytool import` — import mnemonic or bech32 private key (`suiprivkey...`)

- `sui keytool list` — list keys in the CLI keystore

- `sui keytool export <alias|address>` — export private key as bech32 `suiprivkey...`

- `sui keytool sign` — create a signature with a key in keystore

Notes and flags:

- `--keystore-path` — override the default path where keys are stored

- Many commands support `--json` to return machine-readable output

Multi-sig helpers:

- `multi-sig-address`, `multi-sig-combine-partial-sig`, and `multi-sig-combine-partial-sig-legacy`
  are provided to create and combine multisig signatures for use with `sui client`.

ZK-login helpers (testing and production flows):

- `zk-login-sign-and-execute-tx`, `zk-login-enter-token`, `zk-login-sig-verify`,
  `zk-login-insecure-sign-personal-message` — used for zero-knowledge login flows (follow
  help text carefully; some commands are testing-only).

### `sui keytool` subcommands (detailed)

- `sui keytool generate <KEY_SCHEME> [DERIVATION_PATH] [WORD_LENGTH]`
  - Generate a keypair file (Base64 flag||privkey). Key schemes: ed25519, secp256k1,
    secp256r1. Default derivation paths and default mnemonic word length (12) are used
    unless overridden. Use `--json` for machine output.

- `sui keytool import <INPUT_STRING> <KEY_SCHEME> [DERIVATION_PATH] [--alias ALIAS]`
  - Import mnemonic or Bech32 `suiprivkey...` into the CLI keystore. `--alias` sets a
    friendly alias (must start with a letter; letters, digits, - and _ allowed).

- `sui keytool export --key-identity <KEY_IDENTITY>`
  - Export the private key of a key identity as Bech32 `suiprivkey...` (use `--json`
    for JSON output).

- `sui keytool list [--sort-by-alias]`
  - List keys in the keystore. Use `--sort-by-alias` to sort results.

- `sui keytool sign --address <ADDRESS> --data <DATA> [--intent INTENT]`
  - Sign data using a key present in the keystore. Useful to create signatures for
    pre-built transactions or messages. `--intent` selects the intent wrapping.

- `sui keytool sign-kms --data <DATA> --keyid <KEYID> --base64pk <BASE64PK>`
  - Create a signature using AWS KMS. Provide KMS key-id and base64-encoded pubkey.

- `sui keytool convert <VALUE>`
  - Convert hex/base64 private keys to bech32 `suiprivkey` format.

- `sui keytool decode-or-verify-tx --tx-bytes <TX_BYTES> [--sig <SIG>] [--cur-epoch N]`
  - Decode base64 transaction bytes. If signature provided, verify it.

- `sui keytool decode-multi-sig --multisig <MULTISIG> [--tx-bytes <TX_BYTES>]`
  - Decode a Base64 multisig and optionally verify it against transaction bytes.

- `sui keytool load-keypair <FILE>`
  - Load arbitrary serialized keypair files and print component keypairs.

- `sui keytool multi-sig-address --threshold <THRESHOLD> --pks <PKS>... [--weights W...]`
  - Create a multisig address from a list of Base64 public keys and weights.

- `sui keytool multi-sig-combine-partial-sig --threshold <THRESHOLD> --pks <PKS>... --sigs <SIGS>... --weights <WEIGHTS>...`
  - Combine partial multisig signatures into a single MultiSig signature. Order of
    `sigs` must match `pks`. Returns a Base64 multisig sig usable by `sui client`.

- `sui keytool show <FILE>`
  - Print public key and key scheme of a keypair file.

- `sui keytool unpack <KEYPAIR>`
  - Write keypair files to disk using the address as the filename and print metadata.

- ZkLogin helpers (detailed)
  - `sui keytool zk-login-sign-and-execute-tx --max-epoch <MAX_EPOCH> [--network devnet] [--fixed] [--test-multisig] [--sign-with-sk]`
    - Interactive flow: generates OAuth URL, asks for redirect paste, calls salt/prover
      servers, signs a test transaction with ephemeral key and executes it.

  - `sui keytool zk-login-enter-token --parsed-token <PARSED_TOKEN> --max-epoch <MAX_EPOCH> --jwt-randomness <JWT_RANDOMNESS> --kp-bigint <KP_BIGINT> --ephemeral-key-identifier <EPHEMERAL_KEY_IDENTIFIER> [--network devnet] [--test-multisig] [--sign-with-sk]`
    - Non-interactive helper for entering token data printed by the interactive flow.

  - `sui keytool zk-login-sig-verify --sig <SIG> --intent-scope <INTENT_SCOPE> [--bytes <BYTES>] [--cur-epoch N] [--network devnet]`
    - Verify and parse a zkLogin signature. `--intent-scope` is 0 for TransactionData or 3
      for PersonalMessage.

  - `sui keytool zk-login-insecure-sign-personal-message --data <DATA> --max-epoch <MAX_EPOCH>`
    - Testing-only: create a fixed ephemeral key + JWT issuer and sign arbitrary data.
  
## Client (`sui client`) — everyday user commands

Global flags for `sui client`:

- `--client.config <CONFIG>` — file storing user's account state (addresses, envs)

- `--client.env <ENV>` — choose which environment (devnet/local) to use from the config

- `--json` — return output as JSON

Common actions:

- `sui client faucet [--address <ADDR>] [--url <URL>]` — request test gas

- `sui client publish [package_path]` — compile & publish a Move package (lots of flags;
  use `--dry-run`/`--serialize-*` for safe experimentation)

- `sui client call --package <pkg> --module <mod> --function <fn> --args ...` — call Move

- `sui client transfer-sui --to <addr> --sui-coin-object-id <id> [--amount <amt>]` — send SUI

- `sui client pay|pay-sui|pay-all-sui` — coin payment primitives

Publishing notes:

- `--gas`, `--gas-budget`, `--gas-price` control gas selection and budgets. If omitted the
  CLI will attempt to estimate.

- `--dry-run`, `--dev-inspect` and `--serialize-unsigned-transaction` are useful to
  understand side-effects without executing on-chain.

Serialization helpers:

- Multiple commands (publish, call, pay, transfer) accept `--serialize-unsigned-transaction`
  or `--serialize-signed-transaction` to get base64-encoded BCS bytes which can be executed
  elsewhere with `sui client execute-signed-tx` or `sui client execute-combined-signed-tx`.

Example: dry-run a transfer

```bash
sui client transfer-sui --to 0xabc... --sui-coin-object-id 0xCoinId --amount 100 --dry-run
```

### `sui client` subcommands (detailed)

- `sui client execute-signed-tx --tx-bytes <TX_BYTES> [--signatures <SIGS>...]`
  - Execute a signed transaction when signatures are prepared externally. `--tx-bytes`
    expects base64-encoded BCS TransactionData (the output of `--serialize-unsigned-transaction`).

- `sui client execute-combined-signed-tx --signed-tx-bytes <SIGNED_TX_BYTES>`
  - Execute a combined SenderSignedData BCS bytes (base64) produced by `--serialize-signed-transaction`.

- `sui client serialized-tx-kind <TX_BYTES> [--gas ...] [--dry-run] [--dev-inspect] [--serialize-*]`
  - Inspect/execute a serialized TransactionKind. Accepts gas selection, budgets, and the
    same serialize/dry-run flags used elsewhere.

- `sui client ptb` — programmable transaction block helper (powerful; many flags)
  - Useful flags and examples:
    - `--assign NAME VALUE` — bind variables for reuse in PTB sequence
    - `--move-call PACKAGE::MODULE::FUNCTION <TYPE_ARGS> <FUNCTION_ARGS>` — run Move call
    - `--split-coins COIN [AMOUNTS]`, `--merge-coins INTO [COINS]`, `--transfer-objects [OBJS] TO`
    - `--publish <PATH>` / `--upgrade <PATH>` — publish or upgrade Move packages inside PTB
    - `--dry-run` / `--dev-inspect` / `--preview` — safe inspection modes
    - `--serialize-unsigned-transaction` / `--serialize-signed-transaction` — output BCS
    - `--gas-coin`, `--gas-budget`, `--gas-price`, `--gas-sponsor` control gas usage

  - PTB is interactive in how it binds results (use `--assign`), and it's the recommended
    way to construct multi-step transactions reproducibly in scripts.

- `sui client ptb --help` will show more examples and usage patterns if you plan to build PTBs.

- `sui client ptb --assign X [..] --move-call ... --assign out` is commonly used to chain
  creation, call, and transfer operations.

- `sui client serialized-tx` and `sui client serialized-tx-kind` are the main entry points when
  working with raw serialized transaction bytes.

- `sui client active-address` — show the active address used by the client (supports `--json`).
- `sui client active-env` — show the active environment used by the client (supports `--json`).
- `sui client addresses` — list addresses managed by the client (no flags besides `--json`).
- `sui client balance [ADDRESS] [--coin-type <COIN_TYPE>] [--with-coins] [--json]` — show
  balances; `--with-coins` prints detailed coin objects.
- `sui client chain-identifier` — query chain identifier from RPC (useful post-start).
- `sui client dynamic-field <object_id> [--cursor <CURSOR>] [--limit <LIMIT>] [--json]` —
  page dynamic fields under an object.
- `sui client envs` — list configured client environments (`--json` available).
- `sui client new-env --alias <ALIAS> --rpc <RPC> [--ws <WS>] [--basic-auth <USER:PASS>]`
  — add a new environment to the client config.
- `sui client new-address [KEY_SCHEME] [DERIVATION_PATH] [WORD_LEN]` — convenience wrapper
  to create and store a new address in the CLI keystore; mirrors `keytool generate` but
  stores in the keystore.
- `sui client object <object_id> [--bcs] [--json]` — fetch object info or raw BCS bytes.

### Replay / trace / analysis

- `sui replay` has options for replaying single digests or batch files and saving trace
  artifacts. Key flags:
  - `-d, --digest <DIGEST>` — single transaction digest to replay
  - `--digests-path <FILE>` — file with digest list
  - `--trace` — save execution traces to output dir
  - `-o, --output-dir <DIR>` — where artifacts are stored
  - `--terminate-early` — stop on first error in batch replays

- `sui analyze-trace --path <PATH> gas-profile` — turn a trace into a speedscope-compatible
  gas profile. Use `-u/--use-long-function-name` to include module/address in names.

### Fire drill

- `sui fire-drill metadata-rotation --sui-node-config-path <SUI_NODE_CONFIG_PATH> --account-key-path <ACCOUNT_KEY_PATH> --fullnode-rpc-url <FULLNODE_RPC_URL>`
  - Run metadata rotation fire-drill against a running fullnode. Provide node config path,
    account key file and a reliable fullnode RPC URL.

## Validator and node tooling

- `sui validator` commands help create metadata, join/leave committee, and manage
  validator-specific configuration.
- `sui bridge-committee-init` helps initialize bridge committee config when running a
  local bridge cluster.

## Misc tools

- `sui move <subcommand>` — build, test, and manage Move packages (see `sui move --help`)
- `sui analyze-trace --path <trace> gas-profile` — create gas profile for speedscope
- `sui replay` — replay transactions/traces (used by CLI and config files)
- `sui analyze-trace` and `sui replay` have output options for debugging and offline
  inspection

## Sui Move CLI (full command tree)

The `sui move` command is the primary developer-facing tool for Move packages. Below is a
complete, concise expansion of the Move command tree (subcommands + important flags). Use
`sui move <subcommand> --help` for examples and more details.

- `sui move build`
  - Build a Move package. Key flags: `-p/--path`, `-d/--dev`, `--test`, `--doc`,
    `--disassemble`, `--install-dir`, `--force`, `--dump-bytecode-as-base64`,
    `--generate-struct-layouts`, `--ignore-chain`, `--with-unpublished-dependencies`.

- `sui move coverage` (has nested subcommands)
  - `sui move coverage summary` — coverage summary for all modules. Flags: `-p/--path`,
    `--summarize-functions`, `--csv`, plus standard build/test flags.
  - `sui move coverage source --module <MODULE_NAME>` — coverage relative to source.
  - `sui move coverage bytecode --module <MODULE_NAME>` — coverage relative to disassembled bytecode.
  - `sui move coverage lcov` — generate lcov-style output; supports `--only-test` and
    `--differential-test`.

- `sui move disassemble <module_path>`
  - Disassemble `.mv` bytecode files. Flags: `--Xdebug`, `--bytecode-map`, `-p/--path`,
    and other standard flags.

- `sui move manage-package`
  - Record addresses (object IDs) for where a package is published on-chain and set
    entries in Move.lock. Important flags: `--environment`, `--network-id`,
    `--original-id`, `--latest-id`, `--version-number`, `-p/--path`.

- `sui move migrate [path]`
  - Migrate packages to newer Move editions/format (Move 2024 migration helper).
- `sui move new <NAME>`
  - Create a new Move package scaffold. Flags: `-p/--path`, `-d/--dev`, `--test`, `--doc`.

- `sui move test [filter]`
  - Run unit tests. Important flags: `-i/--gas-limit`, `-p/--path`, `-l/--list`,
    `-t/--threads`, `--coverage`, `--statistics`, `--seed`, `--trace`, `--verbose`, and
    many of the standard compilation flags.

- `sui move summary`
  - Generate serialized summaries of package contents. Flags: `-o/--output-format`,
    `-p/--path`, `--output-directory`, `--bytecode`, `--package-id`.

Common flags across many `sui move` subcommands

- `-p, --path <PACKAGE_PATH>`: path to the Move package (defaults to current dir)

- `-d, --dev`, `--test`, `--doc`: control compilation mode

- `--disassemble`: save disassembly and bytecode maps

- `--install-dir <INSTALL_DIR>`, `--force`, `--fetch-deps-only`, `--skip-fetch-latest-git-deps`

- `--default-move-flavor`, `--default-move-edition`

- `--dependencies-are-root`, `--silence-warnings`, `--warnings-are-errors`

- `--json-errors`, `--no-lint`, `--lint`, `--mode`

Practical examples
-- Build & dump bytecode as base64 (good for publishing automation):

```bash
sui move build -p ./my_package --dump-bytecode-as-base64 --install-dir ./out
```

- Run tests with coverage enabled and generate a coverage summary:

```bash
sui move test -p ./my_package --coverage --threads 4
sui move coverage summary -p ./my_package --csv
```

- Create a new Move package scaffold:

```bash
sui move new my_package -p ./
```

If you'd like, I can convert this tree into a machine-readable JSON/YAML file for
automated doc generation, or add command examples into the site's `content/` so they are
visible on the Hugo site.

## Quick examples and recipes

- Serve the site of Move documentation locally while running a local Sui network:
  1. `sui genesis --write-config ./sui-config --with-faucet`
  2. `sui start --network.config ./sui-config --with-indexer --with-graphql`
  3. In another terminal, `sui client faucet --address <your-address>`

- Publish & upgrade a package (basic):
  1. `sui client publish --path ./my_package`
  2. Use returned package ID in subsequent `sui client call` / `sui client publish --with-unpublished-dependencies`

## Where to look in this repository

- This repo is a Hugo site — see `content/` for guides and examples that may reference Sui
  commands.
- There are no direct integrations with `sui` binaries in the source tree; this document is
  meant to help contributors run and test Sui-related flows locally.

---

If you'd like, I can expand any individual section into more detailed step-by-step recipes
(for example: setting up Postgres for the indexer, publishing a Move package with reproducible
gas settings, or full genesis-ceremony walkthroughs). Which section should I expand first?
Below are four expanded, ready-to-run recipes you requested. They are concrete, minimal,
and focused on local development workflows. Run each command in a terminal (zsh) in the
repository root unless otherwise noted.

## 1) Full genesis-ceremony walkthrough (local dev)

Goal: create a local genesis, add a simple validator, and produce a genesis usable by
`sui start`.

Assumptions: `sui` binary is installed and on PATH; working directory is writable.

Steps:

1. Create a working directory for network configs:

```bash
mkdir -p ./sui-local
```

1. Build and write a genesis config (includes faucet):

```bash
sui genesis --write-config ./sui-local --with-faucet --committee-size 4
```

This writes files into `./sui-local` (genesis blob, validator keys, configs).

1. (Optional) Inspect the generated files:

```bash
ls -l ./sui-local
cat ./sui-local/genesis.blob | head -n 10
```

1. Use the `genesis-ceremony` helpers to list validators, add one, and finalize. Example
adding a validator (use real key file paths created by `sui genesis` if present):

```bash
# Example: add a validator (replace paths with files under ./sui-local if different)
sui genesis-ceremony add-validator \
  --name my-local-val \
  --validator-key-file ./sui-local/validator-0/validator-key.pem \
  --worker-key-file ./sui-local/validator-0/worker-key.pem \
  --account-key-file ./sui-local/validator-0/account-key.pem \
  --network-key-file ./sui-local/validator-0/network-key.pem \
  --network-address 127.0.0.1:12345 \
  --p2p-address 127.0.0.1:45678 \
  --narwhal-primary-address 127.0.0.1:6789 \
  --narwhal-worker-address 127.0.0.1:6790 \
  --description "local validator"
```

1. Build unsigned checkpoint, verify signoffs and finalize (minimal example):

```bash
sui genesis-ceremony build-unsigned-checkpoint
sui genesis-ceremony verify-and-sign --key-file ./sui-local/validator-0/validator-key.pem
sui genesis-ceremony finalize
```

1. Start the network using the written config directory:

```bash
sui start --network.config ./sui-local
```

Verification:

- `sui start` should print node startup logs and bind RPC ports (e.g., fullnode RPC 9000).
- Use the client to query chain identifier:

```bash
sui client chain-identifier --client.config ./sui-local/client.yaml
```

If the command returns a chain id, genesis and start were successful.

Notes:

- For repeated experiments, either remove `./sui-local` or run `sui start --force-regenesis`
  to rebuild on each run.
- The exact key filenames produced by `sui genesis` may vary; adapt the paths above.

## 2) Postgres + Indexer + GraphQL setup (local)

Goal: run Postgres locally, start `sui start` with the indexer and GraphQL enabled, and
verify GraphQL endpoint is available.

Quick approach using Docker (no host Postgres install required):

1. Start a Postgres container for the indexer:

```bash
docker run -d --name sui-postgres -p 5432:5432 \
  -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgrespw -e POSTGRES_DB=sui_indexer \
  postgres:15
```

1. Wait for Postgres to be ready (a few seconds). Then run `sui start` with indexer and
   graphql enabled, pointing to the DB:

```bash
sui start --network.config ./sui-local \
  --with-indexer --with-graphql \
  --pg-host localhost --pg-port 5432 --pg-user postgres --pg-password postgrespw --pg-db-name sui_indexer
```

1. Verify the indexer connected and GraphQL is listening (default 0.0.0.0:9125):

```bash
# check GraphQL (quick HTTP status)
curl -sSf http://localhost:9125/ || echo "GraphQL not responding yet"

# check Postgres connection from host (optional)
psql "host=localhost port=5432 user=postgres password=postgrespw dbname=sui_indexer" -c '\l'
```

Notes and tips:

- By default GraphQL depends on indexer; `--with-graphql` will enable indexer if not set.

- If indexer fails with DB errors, check Postgres logs:

```bash
docker logs -f sui-postgres
```

- To run Postgres without Docker, create DB/user and ensure `--pg-*` flags match your
  psql connection parameters.

## 3) PTB cookbook (programmable transaction blocks)

Goal: show common PTB patterns: creating variables, splitting/merging coins, move-calls,
publishing, and serializing PTBs for later execution.

Basic PTB examples (use `sui client ptb`):

- Assign the result of a previous operation to a variable:

```bash
# Bind an amount to MYAMT
sui client ptb --assign MYAMT 100 --move-call std::option::is_none '<u64>' none
```

- Split coins and use the results in the same PTB:

```bash
sui client ptb --split-coins @my_coin_obj_id '[1000,5000]' --assign new_coins \
  --transfer-objects '[new_coins.0]' @recipient_address --preview
```

- Publish a Move package inside a PTB and capture the upgrade capability:

```bash
sui client ptb --publish ./my_move_pkg --assign publish_out --summary
# follow-up: use publish_out (e.g., upgrade cap) in later PTB operations
```

- Serialize the PTB to unsigned transaction bytes (for offline signing):

```bash
sui client ptb --move-call mypkg::mymod::mf '<>' '[]' --serialize-unsigned-transaction > unsigned_tx.b64
```

- Execute a serialized signed transaction that you obtained by signing `unsigned_tx.b64` elsewhere:

```bash
sui client execute-signed-tx --tx-bytes $(cat unsigned_tx.b64) --signatures 'BASE64SIG'
```

PTB tips:

- Use `--preview` or `--dry-run` aggressively while building PTBs.

- Use `--assign` to name intermediate results. When referencing assigned vectors use
  `name.index` (e.g., `new_coins.0`).
- When scripting PTBs, prefer `--serialize-unsigned-transaction` and sign with an
  HSM/KMS or offline tool, then `execute-signed-tx` to submit.

## 4) Troubleshooting appendix — common errors and fixes

These are patterns you'll encounter while iterating locally. Quick checks and fixes.

- "address already in use" when starting nodes
  - Cause: port conflict (9000, 9123, 9124, 9125 are common). Fix: stop the process using the
    port or change the `--fullnode-rpc-port` / `--with-faucet` port mapping.
  - Inspect: `ss -ltnp | grep <port>` or `lsof -i :<port>`.

- Indexer can't connect to Postgres
  - Cause: wrong `--pg-*` flags or DB not running.
  - Fix: ensure Postgres is reachable (see Docker run above) and flags match. Check Postgres
    logs and indexer output printed by `sui start`.

- Keystore / key import errors
  - Use `sui keytool import` for `suiprivkey...` or mnemonics; use `--alias` to set names.
  - If keys don't show up, check `--keystore-path` if you use a non-default location.

- "no genesis found" or start fails with missing config
  - Ensure you passed the same `--network.config` used by `sui genesis --write-config`, or
    run `sui genesis --write-config` before `sui start`.

- Transaction rejections / gas errors
  - Try `--dry-run` or `--dev-inspect` to see failing checks before submitting.
  - Increase `--gas-budget` or set `--gas-price` if network rejects due to low gas.

- Mismatched protocol-config or fork errors in multi-node tests
  - Protocol config overrides can be set via env vars: `SUI_PROTOCOL_CONFIG_OVERRIDE_<param>=value`.
  - Ensure the same overrides are applied to all nodes, or run locally only.

- Where to find logs
  - For local runs, `sui start` streams logs to your terminal. If you used `--network.config`
    check the directory for node-specific logs. For Dockerized Postgres: `docker logs -f sui-postgres`.
